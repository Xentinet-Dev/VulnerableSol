/**
 * Advanced Fuzz Engine
 * 
 * Generates diverse test payloads for exploit simulation:
 * - Random byte mutations
 * - Arithmetic overflow/underflow payloads
 * - Struct-shape fuzzing
 * - Grammar-based fuzzing (ASCII tokens)
 */

export class FuzzEngine {
  /**
   * Random byte fuzzing
   * Generates random byte arrays of varying sizes
   */
  static byteMutations(count: number = 8, max: number = 128): Buffer[] {
    const out: Buffer[] = [];
    for (let i = 0; i < count; i++) {
      const size = Math.floor(Math.random() * max) + 1; // At least 1 byte
      const buf = Buffer.alloc(size);
      for (let j = 0; j < size; j++) {
        buf[j] = Math.floor(Math.random() * 256);
      }
      out.push(buf);
    }
    return out;
  }

  /**
   * Arithmetic overflow / underflow payloads
   * Generates extreme numeric values to trigger arithmetic issues
   */
  static numericMutations(): Buffer[] {
    return [
      Buffer.from([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]), // u64::MAX
      Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), // 0
      Buffer.from([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), // i64::MIN (signed)
      Buffer.from([0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]), // i64::MAX (signed)
      Buffer.from([0x01]), // 1
      Buffer.from([0xff]), // 255
      Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]), // 1 (u64)
    ];
  }

  /**
   * Struct-shape fuzzing
   * Generates buffers of common struct sizes with pattern fills
   */
  static structMutations(): Buffer[] {
    const sizes = [8, 16, 32, 64, 128, 256];
    const patterns = [0x00, 0xff, 0xaa, 0x55, 0x13, 0x37];
    
    const out: Buffer[] = [];
    for (const size of sizes) {
      for (const pattern of patterns) {
        out.push(Buffer.alloc(size, pattern));
      }
    }
    return out;
  }

  /**
   * Grammar-based fuzzing (ASCII tokens)
   * Generates common attack strings and malformed inputs
   */
  static grammarMutations(): Buffer[] {
    const patterns = [
      "DROP TABLE",
      "AAAAAAAAAAAAAA",
      "ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥",
      "INVALID-SEED-123",
      "0000000000000000000",
      "../../../etc/passwd",
      "<script>alert('xss')</script>",
      "'; DROP TABLE users; --",
      "\x00\x00\x00\x00",
      "\xff\xfe\xfd\xfc",
      "admin",
      "root",
      "test",
      "",
    ];
    return patterns.map((p) => Buffer.from(p, "utf8"));
  }

  /**
   * Solana-specific fuzzing
   * Generates payloads that target Solana-specific vulnerabilities
   */
  static solanaMutations(): Buffer[] {
    return [
      // Invalid instruction discriminators
      Buffer.from([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
      Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
      
      // Invalid account indices
      Buffer.from([0xff, 0x00]),
      Buffer.from([0x00, 0xff]),
      
      // Malformed seeds
      Buffer.from("seed".repeat(32).slice(0, 32)),
      Buffer.alloc(32, 0x00),
      Buffer.alloc(32, 0xff),
    ];
  }

  /**
   * Combined fuzzy payload set
   * Returns all generated payloads for comprehensive testing
   */
  static generatePayloads(): Buffer[] {
    return [
      ...this.byteMutations(5, 64), // Smaller random mutations
      ...this.numericMutations(),
      ...this.structMutations().slice(0, 10), // Limit struct mutations
      ...this.grammarMutations(),
      ...this.solanaMutations(),
    ];
  }

  /**
   * Generate boundary test payloads
   * Tests edge cases and boundary conditions
   */
  static boundaryMutations(): Buffer[] {
    const payloads: Buffer[] = [];
    
    // u8 boundaries
    payloads.push(
      Buffer.from([0]),      // Minimum
      Buffer.from([1]),      // Minimum + 1
      Buffer.from([127]),    // i8::MAX (signed)
      Buffer.from([128]),    // i8::MIN (unsigned)
      Buffer.from([254]),   // Maximum - 1
      Buffer.from([255])    // Maximum
    );
    
    // u64 boundaries
    const u64Max = 0xFFFFFFFFFFFFFFFFn;
    const u64MaxBuffer = Buffer.allocUnsafe(8);
    u64MaxBuffer.writeBigUInt64BE(u64Max, 0);
    
    const u64Min = 0n;
    const u64MinBuffer = Buffer.allocUnsafe(8);
    u64MinBuffer.writeBigUInt64BE(u64Min, 0);
    
    const u64One = 1n;
    const u64OneBuffer = Buffer.allocUnsafe(8);
    u64OneBuffer.writeBigUInt64BE(u64One, 0);
    
    payloads.push(
      u64MinBuffer,          // 0
      u64OneBuffer,          // 1
      Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE]), // MAX - 1
      u64MaxBuffer           // MAX
    );
    
    // i64 boundaries (signed)
    const i64Min = -(2n ** 63n);
    const i64MinBuffer = Buffer.allocUnsafe(8);
    i64MinBuffer.writeBigInt64BE(i64Min, 0);
    
    const i64Max = 2n ** 63n - 1n;
    const i64MaxBuffer = Buffer.allocUnsafe(8);
    i64MaxBuffer.writeBigInt64BE(i64Max, 0);
    
    const i64NegOne = -1n;
    const i64NegOneBuffer = Buffer.allocUnsafe(8);
    i64NegOneBuffer.writeBigInt64BE(i64NegOne, 0);
    
    payloads.push(
      i64MinBuffer,          // i64::MIN
      Buffer.from([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]), // MIN + 1
      i64NegOneBuffer,       // -1
      Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]), // 1
      Buffer.from([0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE]), // MAX - 1
      i64MaxBuffer           // i64::MAX
    );
    
    // Empty arrays
    payloads.push(
      Buffer.alloc(0)        // Empty buffer
    );
    
    // Large arrays (test for DoS)
    payloads.push(
      Buffer.alloc(1000, 0xFF),      // 1KB
      Buffer.alloc(10000, 0xAA),      // 10KB
      Buffer.alloc(65536, 0x00)       // 64KB (max instruction data)
    );
    
    // Power-of-two boundaries
    for (let i = 0; i <= 16; i++) {
      const size = 2 ** i;
      if (size <= 65536) {
        payloads.push(Buffer.alloc(size, 0xFF));
      }
    }
    
    return payloads;
  }

  /**
   * Generate payloads for a specific exploit type
   */
  static generatePayloadsForExploit(exploitType: string): Buffer[] {
    const basePayloads = this.generatePayloads();
    const boundaryPayloads = this.boundaryMutations();
    
    // Add type-specific payloads
    switch (exploitType.toLowerCase()) {
      case "overflow":
      case "underflow":
      case "arithmetic":
      case "unchecked_arithmetic":
        return [...basePayloads, ...this.numericMutations(), ...boundaryPayloads];
      
      case "type_confusion":
      case "deserialization":
      case "deserialization_panic":
        return [...basePayloads, ...this.structMutations(), ...boundaryPayloads];
      
      case "pda":
      case "seed":
      case "pda_spoofing":
        return [...basePayloads, ...this.solanaMutations(), ...boundaryPayloads];
      
      case "reentrancy":
        return [...basePayloads, ...this.generateReentrancyPayloads(), ...boundaryPayloads];
      
      case "flash_loan":
      case "oracle":
      case "weak_oracle":
        return [...basePayloads, ...this.generateFlashLoanPayloads(), ...boundaryPayloads];
      
      case "sandwich":
      case "mev":
        return [...basePayloads, ...this.generateMEVPayloads(), ...boundaryPayloads];
      
      default:
        return [...basePayloads, ...boundaryPayloads];
    }
  }
  
  /**
   * Generate reentrancy-specific payloads
   */
  static generateReentrancyPayloads(): Buffer[] {
    return [
      Buffer.from([1]),   // Depth 1
      Buffer.from([2]),   // Depth 2
      Buffer.from([3]),   // Depth 3
      Buffer.from([5]),   // Depth 5
      Buffer.from([10]),  // Depth 10
      Buffer.from([255])  // Max depth
    ];
  }
  
  /**
   * Generate flash loan attack payloads
   */
  static generateFlashLoanPayloads(): Buffer[] {
    const amounts: bigint[] = [
      1n,
      1000n,
      1_000_000n,
      1_000_000_000n,
      1_000_000_000_000n,  // 1 trillion
      18_446_744_073_709_551_615n  // u64::MAX
    ];
    
    return amounts.map(amount => {
      const buffer = Buffer.allocUnsafe(8);
      buffer.writeBigUInt64BE(amount, 0);
      return buffer;
    });
  }
  
  /**
   * Generate MEV/sandwich attack payloads
   */
  static generateMEVPayloads(): Buffer[] {
    return [
      Buffer.from("frontrun"),      // Front-run indicator
      Buffer.from("backrun"),       // Back-run indicator
      Buffer.from("sandwich"),      // Sandwich attack
      Buffer.from([0x01, 0x00]),    // Slippage tolerance 1%
      Buffer.from([0x05, 0x00]),    // Slippage tolerance 5%
      Buffer.from([0x0A, 0x00]),    // Slippage tolerance 10%
      Buffer.from([0xFF, 0xFF])     // Max slippage
    ];
  }

  /**
   * Attach fuzz payloads to a strategy
   */
  static attach(strategy: any): any {
    strategy.fuzzPayloads = FuzzEngine.generatePayloads();
    return strategy;
  }
}

