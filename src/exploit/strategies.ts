/**
 * Exploit Strategies
 * 
 * Strategy-based exploit instruction builders.
 * Each strategy corresponds to a vulnerability type and builds
 * exploit instructions using the program's IDL.
 */

import { PublicKey, TransactionInstruction, Keypair } from "@solana/web3.js";
import { ExploitStrategy, ExploitContext, Idl } from "./exploit-types.js";

/**
 * All exploit strategies return a TransactionInstruction builder.
 * They MUST be named exactly the same as the vulnerability detector's key.
 */
export const ExploitStrategies: ExploitStrategy[] = [
  {
    name: "missing_signer",
    description: "Attempt instruction without required signer accounts.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      // Find instruction that might require signers
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("transfer") ||
        i.name.toLowerCase().includes("withdraw") ||
        i.name.toLowerCase().includes("admin")
      );

      if (!ix && idl.instructions.length > 0) {
        // Use first instruction if no match
        const firstIx = idl.instructions[0];
        return buildInstructionFromIdl(firstIx, programId, accounts, fuzzPayload, true);
      }

      if (!ix) return null;

      // Force missing signer by setting all accounts to non-signer
      const altered = accounts.map((a) => ({
        ...a,
        signer: false,
        isSigner: false,
      }));

      return buildInstructionFromIdl(ix, programId, altered, fuzzPayload);
    },
  },

  {
    name: "unchecked_owner",
    description: "Provide arbitrary writable accounts to bypass owner checks.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("owner") ||
        i.name.toLowerCase().includes("account")
      ) || idl.instructions[0];

      if (!ix) return null;

      // Make all accounts writable
      const arbitrary = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        writable: true,
        isWritable: true,
        signer: false,
        isSigner: false,
      }));

      return buildInstructionFromIdl(ix, programId, arbitrary, fuzzPayload);
    },
  },

  {
    name: "type_confusion",
    description: "Substitute malicious program for expected program in CPI calls.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload, vulnerability }: ExploitContext): Promise<TransactionInstruction | null> {
      // Find instruction that makes CPI calls
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("invoke") ||
        i.name.toLowerCase().includes("call") ||
        i.name.toLowerCase().includes("transfer") ||
        i.name.toLowerCase().includes("swap")
      ) || idl.instructions[0];

      if (!ix) return null;

      // Create accounts with malicious program substituted
      // The malicious program should be in the accounts list
      const maliciousProgram = accounts.find((a: any) => 
        a.pubkey && a.pubkey.toString() !== programId.toString()
      )?.pubkey || Keypair.generate().publicKey;

      // Build instruction that would call with malicious program
      const maliciousAccounts = accounts.map((a: any, idx: number) => {
        // Substitute program account with malicious program
        if (idx === 1 || a.name?.toLowerCase().includes("program") || a.name?.toLowerCase().includes("token_program")) {
          return {
            pubkey: maliciousProgram,
            isWritable: false,
            isSigner: false,
          };
        }
        return {
          pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
          isWritable: a.isWritable || a.isMut || false,
          isSigner: a.isSigner || false,
        };
      });

      return buildInstructionFromIdl(ix, programId, maliciousAccounts, fuzzPayload);
    },
  },

  {
    name: "arbitrary_write",
    description: "Try to write unbounded data into writable accounts.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("write") ||
        i.name.toLowerCase().includes("update") ||
        i.name.toLowerCase().includes("set")
      ) || idl.instructions[0];

      if (!ix) return null;

      const data = fuzzPayload || Buffer.alloc(64, 0xff);

      const keys = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        isWritable: true,
        isSigner: false,
      }));

      return buildInstructionFromIdl(ix, programId, keys, data);
    },
  },

  {
    name: "reentrancy",
    description: "Attempt recursive CPI loops to trigger reentrancy.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("call") ||
        i.name.toLowerCase().includes("invoke")
      ) || idl.instructions[0];

      if (!ix) return null;

      const loopDepth = fuzzPayload?.[0] || 3;
      const depthBuffer = Buffer.from([loopDepth]);

      const keys = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        isWritable: !!a.writable || !!a.isMut,
        isSigner: !!a.signer || !!a.isSigner,
      }));

      return buildInstructionFromIdl(ix, programId, keys, depthBuffer);
    },
  },

  {
    name: "pda_spoofing",
    description: "Fake PDA seeds to break seed constraints.",
    async buildInstruction({ idl, programId, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("pda") ||
        i.name.toLowerCase().includes("seed") ||
        i.name.toLowerCase().includes("derive")
      ) || idl.instructions[0];

      if (!ix) return null;

      const fakeSeeds = fuzzPayload || Buffer.from("seedseedseed");

      return buildInstructionFromIdl(ix, programId, [], fakeSeeds);
    },
  },

  {
    name: "authority_misuse",
    description: "Forge authority arguments to bypass authority validation.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("authority") ||
        i.name.toLowerCase().includes("admin") ||
        i.name.toLowerCase().includes("owner")
      ) || idl.instructions[0];

      if (!ix) return null;

      const forged = fuzzPayload || Buffer.alloc(32, 1);

      const keys = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        isWritable: !!a.writable || !!a.isMut,
        isSigner: false, // Try without signer
      }));

      return buildInstructionFromIdl(ix, programId, keys, forged);
    },
  },

  {
    name: "owner_spoofing",
    description: "Pretend an account is owned by a different program.",
    async buildInstruction({ idl, programId, accounts, fuzzPayload }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("owner") ||
        i.name.toLowerCase().includes("account")
      ) || idl.instructions[0];

      if (!ix) return null;

      const spoofedData = fuzzPayload || Buffer.from(Array(32).fill(0x22));

      const keys = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        isWritable: true,
        isSigner: false,
      }));

      return buildInstructionFromIdl(ix, programId, keys, spoofedData);
    },
  },

  {
    name: "unchecked_arithmetic",
    description: "Generate integer overflow/underflow conditions.",
    async buildInstruction({ idl, programId, accounts }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("add") ||
        i.name.toLowerCase().includes("sub") ||
        i.name.toLowerCase().includes("transfer") ||
        i.name.toLowerCase().includes("swap")
      ) || idl.instructions[0];

      if (!ix) return null;

      // Extreme values to trigger overflow
      const payload = Buffer.from([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);

      const keys = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        isWritable: false,
        isSigner: false,
      }));

      return buildInstructionFromIdl(ix, programId, keys, payload);
    },
  },

  {
    name: "deserialization_panic",
    description: "Feed corrupted struct data to force deserialization failure.",
    async buildInstruction({ idl, programId }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions[0]; // Use first instruction

      if (!ix) return null;

      // Corrupted data
      const corrupted = Buffer.alloc(80, 0x13);

      return buildInstructionFromIdl(ix, programId, [], corrupted);
    },
  },

  {
    name: "init_without_rent",
    description: "Attempt init instructions without providing rent lamports.",
    async buildInstruction({ idl, programId, accounts }: ExploitContext): Promise<TransactionInstruction | null> {
      const ix = idl.instructions.find((i: any) => 
        i.name.toLowerCase().includes("init") ||
        i.name.toLowerCase().includes("create")
      ) || idl.instructions[0];

      if (!ix) return null;

      const keys = accounts.map((a) => ({
        pubkey: a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey,
        isWritable: true,
        isSigner: !!a.signer || !!a.isSigner,
      }));

      // Empty data (no rent lamports specified)
      return buildInstructionFromIdl(ix, programId, keys, Buffer.alloc(0));
    },
  },
];

/**
 * Helper function to build instruction from IDL
 */
function buildInstructionFromIdl(
  ix: any,
  programId: PublicKey,
  accounts: any[],
  data?: Buffer,
  forceNoSigner: boolean = false
): TransactionInstruction {
  // Get discriminator
  let discriminator: Buffer;
  if (ix.discriminator) {
    if (typeof ix.discriminator === "string") {
      discriminator = Buffer.from(ix.discriminator, "hex");
    } else if (Array.isArray(ix.discriminator)) {
      discriminator = Buffer.from(ix.discriminator);
    } else {
      // Generate 8-byte discriminator from name (Anchor style)
      discriminator = Buffer.alloc(8);
      const nameHash = require("crypto").createHash("sha256").update(`global:${ix.name}`).digest();
      discriminator = nameHash.slice(0, 8);
    }
  } else {
    // Fallback: use first 8 bytes of instruction name hash (Anchor style with global: prefix)
    const crypto = require("crypto");
    const hash = crypto.createHash("sha256").update(`global:${ix.name}`).digest();
    discriminator = hash.slice(0, 8);
  }

  // Build instruction data
  const instructionData = data 
    ? Buffer.concat([discriminator, data])
    : discriminator;

  // Build account keys
  const keys = accounts.map((a) => ({
    pubkey: a.pubkey instanceof PublicKey ? a.pubkey : (a.pubkey ? new PublicKey(a.pubkey) : Keypair.generate().publicKey),
    isWritable: forceNoSigner ? false : (a.isWritable || a.writable || false),
    isSigner: forceNoSigner ? false : (a.isSigner || a.signer || false),
  }));

  return new TransactionInstruction({
    keys,
    programId,
    data: instructionData,
  });
}

