/**
 * Vulnerability Organizer
 * 
 * Normalizes and groups raw scanner findings into organized buckets
 * for exploit simulation and reporting
 */

import { ScanResult, Vulnerability, Severity, VulnerabilityCategory, GroupedVulnerability } from "../types/vulnerability.js";

export interface GroupedVulnerabilities {
  byCategory: CategoryGroup;
  byFile: FileGroup;
  byAttackSurface: AttackSurfaceGroup;
  summary: VulnerabilitySummary;
}

export interface CategoryGroup {
  [Severity.CRITICAL]: Vulnerability[];
  [Severity.HIGH]: Vulnerability[];
  [Severity.MEDIUM]: Vulnerability[];
  [Severity.LOW]: Vulnerability[];
  [Severity.INFO]: Vulnerability[];
}

export interface FileGroup {
  [filePath: string]: {
    vulnerabilities: Vulnerability[];
    criticalCount: number;
    highCount: number;
    attackSurfaces: string[];
  };
}

export interface AttackSurfaceGroup {
  accountForgery: Vulnerability[];
  programInvocation: Vulnerability[];
  arithmetic: Vulnerability[];
  memoryTruncation: Vulnerability[];
  errorHandling: Vulnerability[];
  accessControl: Vulnerability[];
}

export interface VulnerabilitySummary {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  info: number;
  uniqueFiles: number;
  attackSurfaces: number;
}

/**
 * Organizes vulnerabilities from scan results
 */
export class VulnerabilityOrganizer {
  /**
   * Organize vulnerabilities from scan results
   */
  organize(scanResults: ScanResult[]): GroupedVulnerabilities {
    // Flatten all vulnerabilities from all scan results
    const allVulnerabilities: Vulnerability[] = [];
    for (const result of scanResults) {
      allVulnerabilities.push(...result.vulnerabilities);
    }

    return {
      byCategory: this.groupByCategory(allVulnerabilities),
      byFile: this.groupByFile(allVulnerabilities),
      byAttackSurface: this.groupByAttackSurface(allVulnerabilities),
      summary: this.generateSummary(allVulnerabilities)
    };
  }

  /**
   * Group vulnerabilities by severity category
   */
  private groupByCategory(vulnerabilities: Vulnerability[]): CategoryGroup {
    return {
      [Severity.CRITICAL]: vulnerabilities.filter(v => v.severity === Severity.CRITICAL),
      [Severity.HIGH]: vulnerabilities.filter(v => v.severity === Severity.HIGH),
      [Severity.MEDIUM]: vulnerabilities.filter(v => v.severity === Severity.MEDIUM),
      [Severity.LOW]: vulnerabilities.filter(v => v.severity === Severity.LOW),
      [Severity.INFO]: vulnerabilities.filter(v => v.severity === Severity.INFO)
    };
  }

  /**
   * Group vulnerabilities by file
   */
  private groupByFile(vulnerabilities: Vulnerability[]): FileGroup {
    const fileMap: FileGroup = {};

    for (const vuln of vulnerabilities) {
      const filePath = vuln.location.file || "unknown";
      
      if (!fileMap[filePath]) {
        fileMap[filePath] = {
          vulnerabilities: [],
          criticalCount: 0,
          highCount: 0,
          attackSurfaces: []
        };
      }

      fileMap[filePath].vulnerabilities.push(vuln);
      
      if (vuln.severity === Severity.CRITICAL) {
        fileMap[filePath].criticalCount++;
      } else if (vuln.severity === Severity.HIGH) {
        fileMap[filePath].highCount++;
      }

      // Determine attack surface
      const surface = this.determineAttackSurface(vuln);
      if (!fileMap[filePath].attackSurfaces.includes(surface)) {
        fileMap[filePath].attackSurfaces.push(surface);
      }
    }

    return fileMap;
  }

  /**
   * Group vulnerabilities by attack surface
   */
  private groupByAttackSurface(vulnerabilities: Vulnerability[]): AttackSurfaceGroup {
    return {
      accountForgery: vulnerabilities.filter(v => 
        v.category === VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE &&
        (v.title.includes("Ownership") || v.title.includes("Account Structure"))
      ),
      programInvocation: vulnerabilities.filter(v =>
        v.title.includes("Type Confusion") ||
        v.title.includes("Arbitrary") ||
        v.title.includes("Program Invocation") ||
        v.title.includes("External Program")
      ),
      arithmetic: vulnerabilities.filter(v =>
        v.title.includes("Overflow") ||
        v.title.includes("Underflow") ||
        v.title.includes("Arithmetic") ||
        v.category === VulnerabilityCategory.ARITHMETIC
      ),
      memoryTruncation: vulnerabilities.filter(v =>
        v.title.includes("Truncation") ||
        v.title.includes("Cast")
      ),
      errorHandling: vulnerabilities.filter(v =>
        v.title.includes("Error") ||
        v.title.includes("unwrap") ||
        v.title.includes("panic")
      ),
      accessControl: vulnerabilities.filter(v =>
        v.title.includes("Signer") ||
        v.title.includes("Ownership") ||
        v.title.includes("Authorization") ||
        v.category === VulnerabilityCategory.ACCESS_CONTROL
      )
    };
  }

  /**
   * Determine attack surface from vulnerability
   */
  private determineAttackSurface(vuln: Vulnerability): string {
    const title = vuln.title.toLowerCase();
    
    if (title.includes("ownership") || title.includes("account structure")) {
      return "Account Forgery";
    }
    if (title.includes("type confusion") || title.includes("arbitrary") || title.includes("program")) {
      return "Program Invocation";
    }
    if (title.includes("overflow") || title.includes("underflow") || title.includes("arithmetic")) {
      return "Arithmetic";
    }
    if (title.includes("truncation") || title.includes("cast")) {
      return "Memory Truncation";
    }
    if (title.includes("error") || title.includes("unwrap")) {
      return "Error Handling";
    }
    if (title.includes("signer") || title.includes("authorization")) {
      return "Access Control";
    }
    
    return "Other";
  }

  /**
   * Generate summary statistics
   */
  private generateSummary(vulnerabilities: Vulnerability[]): VulnerabilitySummary {
    const uniqueFiles = new Set(vulnerabilities.map(v => v.location.file).filter(Boolean));
    const attackSurfaces = new Set(vulnerabilities.map(v => this.determineAttackSurface(v)));

    return {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === Severity.CRITICAL).length,
      high: vulnerabilities.filter(v => v.severity === Severity.HIGH).length,
      medium: vulnerabilities.filter(v => v.severity === Severity.MEDIUM).length,
      low: vulnerabilities.filter(v => v.severity === Severity.LOW).length,
      info: vulnerabilities.filter(v => v.severity === Severity.INFO).length,
      uniqueFiles: uniqueFiles.size,
      attackSurfaces: attackSurfaces.size
    };
  }

  /**
   * Get vulnerabilities for a specific file
   */
  getVulnerabilitiesForFile(grouped: GroupedVulnerabilities, filePath: string): Vulnerability[] {
    return grouped.byFile[filePath]?.vulnerabilities || [];
  }

  /**
   * Get vulnerabilities for a specific attack surface
   */
  getVulnerabilitiesForSurface(grouped: GroupedVulnerabilities, surface: keyof AttackSurfaceGroup): Vulnerability[] {
    return grouped.byAttackSurface[surface] || [];
  }

  /**
   * Get top critical vulnerabilities
   */
  getTopCritical(grouped: GroupedVulnerabilities, limit: number = 10): Vulnerability[] {
    return grouped.byCategory[Severity.CRITICAL].slice(0, limit);
  }

  /**
   * Deduplicate and group similar vulnerabilities
   * Groups vulnerabilities by title, category, and severity
   * Returns grouped vulnerabilities with counts
   */
  deduplicate(vulnerabilities: Vulnerability[]): GroupedVulnerability[] {
    const groups = new Map<string, Vulnerability[]>();

    // Group vulnerabilities by key (title + category + severity)
    for (const vuln of vulnerabilities) {
      const key = this.getGroupKey(vuln);
      
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      
      groups.get(key)!.push(vuln);
    }

    // Convert to GroupedVulnerability array
    const grouped: GroupedVulnerability[] = [];
    
    for (const [key, instances] of groups.entries()) {
      // Sort instances by severity (most severe first) and line number
      const sorted = instances.sort((a, b) => {
        const severityOrder = {
          [Severity.CRITICAL]: 0,
          [Severity.HIGH]: 1,
          [Severity.MEDIUM]: 2,
          [Severity.LOW]: 3,
          [Severity.INFO]: 4
        };
        
        const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
        if (severityDiff !== 0) return severityDiff;
        
        // If same severity, sort by line number
        const lineA = a.location.line || 0;
        const lineB = b.location.line || 0;
        return lineA - lineB;
      });

      // Get unique file paths
      const affectedFiles = Array.from(
        new Set(
          instances
            .map(v => v.location.file)
            .filter((f): f is string => Boolean(f))
        )
      );

      // Merge metadata from all instances to preserve repositoryPath and other important metadata
      const mergedMetadata: any = {};
      for (const instance of instances) {
        if (instance.metadata) {
          // Merge metadata, prioritizing non-null values
          for (const [key, value] of Object.entries(instance.metadata)) {
            if (value !== null && value !== undefined && value !== '') {
              if (!mergedMetadata[key] || mergedMetadata[key] === '' || mergedMetadata[key] === null) {
                mergedMetadata[key] = value;
              }
            }
          }
        }
      }

      // Create representative with merged metadata
      const representative = { ...sorted[0] };
      if (Object.keys(mergedMetadata).length > 0) {
        representative.metadata = {
          ...representative.metadata,
          ...mergedMetadata
        };
      }

      grouped.push({
        representative, // Use most severe/first instance with merged metadata
        instances: sorted,
        count: instances.length,
        affectedFiles,
        groupKey: key
      });
    }

    // Sort grouped vulnerabilities by severity and count
    return grouped.sort((a, b) => {
      const severityOrder = {
        [Severity.CRITICAL]: 0,
        [Severity.HIGH]: 1,
        [Severity.MEDIUM]: 2,
        [Severity.LOW]: 3,
        [Severity.INFO]: 4
      };
      
      const severityDiff = 
        severityOrder[a.representative.severity] - 
        severityOrder[b.representative.severity];
      
      if (severityDiff !== 0) return severityDiff;
      
      // If same severity, sort by count (more instances = higher priority)
      return b.count - a.count;
    });
  }

  /**
   * Generate a group key for deduplication
   * Uses title, category, and severity to identify similar vulnerabilities
   */
  private getGroupKey(vulnerability: Vulnerability): string {
    // Normalize title (remove extra whitespace, lowercase for comparison)
    const normalizedTitle = vulnerability.title
      .toLowerCase()
      .trim()
      .replace(/\s+/g, ' ');
    
    // Create key from title, category, and severity
    // This groups vulnerabilities that are the same type
    return `${normalizedTitle}|${vulnerability.category}|${vulnerability.severity}`;
  }

  /**
   * Organize and deduplicate vulnerabilities
   * Returns both grouped (deduplicated) and full list
   */
  organizeAndDeduplicate(scanResults: ScanResult[]): {
    grouped: GroupedVulnerability[];
    full: GroupedVulnerabilities;
    summary: VulnerabilitySummary;
  } {
    // Flatten all vulnerabilities
    const allVulnerabilities: Vulnerability[] = [];
    for (const result of scanResults) {
      allVulnerabilities.push(...result.vulnerabilities);
    }

    // Deduplicate
    const grouped = this.deduplicate(allVulnerabilities);

    // Also provide full organization
    const full = {
      byCategory: this.groupByCategory(allVulnerabilities),
      byFile: this.groupByFile(allVulnerabilities),
      byAttackSurface: this.groupByAttackSurface(allVulnerabilities),
      summary: this.generateSummary(allVulnerabilities)
    };

    return {
      grouped,
      full,
      summary: full.summary
    };
  }
}

