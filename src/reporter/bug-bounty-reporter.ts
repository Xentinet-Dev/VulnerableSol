/**
 * Bug Bounty Report Generator
 * 
 * Automatically generates professional vulnerability disclosure reports
 * for bug bounty submissions
 */

import { Vulnerability, Severity } from "../types/vulnerability.js";
import { ExploitAttempt, ExploitabilityStatus } from "../simulator/exploit-simulator.js";

export interface BugBountyReport {
  title: string;
  summary: string;
  severity: {
    cvss: string;
    solanaSpecific: string;
    financialImpact: string;
  };
  affectedFiles: string[];
  vulnerabilityClass: string[];
  technicalDescription: string;
  reproductionSteps: string[];
  proofOfImpact: string[];
  remediation: string;
  disclosure: {
    discovered: Date;
    simulated: Date;
    reported: Date;
    author: string;
    timeline: string;
  };
  references: string[];
}

/**
 * Generates bug bounty reports from vulnerability and exploit data
 */
export class BugBountyReporter {
  /**
   * Generate a complete bug bounty report
   */
  generateReport(
    vulnerability: Vulnerability,
    exploitAttempt: ExploitAttempt,
    author: string = "Security Researcher"
  ): BugBountyReport {
    return {
      title: this.generateTitle(vulnerability),
      summary: this.generateSummary(vulnerability, exploitAttempt),
      severity: this.calculateSeverity(vulnerability, exploitAttempt),
      affectedFiles: this.getAffectedFiles(vulnerability),
      vulnerabilityClass: this.getVulnerabilityClasses(vulnerability),
      technicalDescription: this.generateTechnicalDescription(vulnerability, exploitAttempt),
      reproductionSteps: this.generateReproductionSteps(vulnerability, exploitAttempt),
      proofOfImpact: this.generateProofOfImpact(exploitAttempt),
      remediation: vulnerability.recommendation || this.generateRemediation(vulnerability),
      disclosure: {
        discovered: new Date(),
        simulated: new Date(),
        reported: new Date(),
        author,
        timeline: this.generateTimeline()
      },
      references: vulnerability.references || []
    };
  }

  /**
   * Generate report as markdown
   */
  generateMarkdownReport(report: BugBountyReport): string {
    return `# ${report.title}

## Executive Summary

${report.summary}

## Severity Assessment

**CVSS Score:** ${report.severity.cvss}  
**Solana-Specific Severity:** ${report.severity.solanaSpecific}  
**Financial Impact:** ${report.severity.financialImpact}

## Affected Files

${report.affectedFiles.map(f => `- \`${f}\``).join("\n")}

## Vulnerability Classification

${report.vulnerabilityClass.map(c => `- ${c}`).join("\n")}

## Technical Description

${report.technicalDescription}

## Reproduction Steps

${report.reproductionSteps.map((step, i) => `${i + 1}. ${step}`).join("\n")}

## Proof of Impact

${report.proofOfImpact.map(p => `- ${p}`).join("\n")}

## Remediation

\`\`\`rust
${report.remediation}
\`\`\`

## Disclosure Information

- **Discovered:** ${report.disclosure.discovered.toISOString()}
- **Simulated:** ${report.disclosure.simulated.toISOString()}
- **Reported:** ${report.disclosure.reported.toISOString()}
- **Author:** ${report.disclosure.author}
- **Timeline:** ${report.disclosure.timeline}

## References

${report.references.map(r => `- ${r}`).join("\n")}

---

**Report Generated by Xentinet Vulnerability Scanner**
`;
  }

  /**
   * Generate report as JSON
   */
  generateJSONReport(report: BugBountyReport): string {
    return JSON.stringify(report, null, 2);
  }

  private generateTitle(vulnerability: Vulnerability): string {
    const severity = vulnerability.severity === Severity.CRITICAL ? "Critical" : 
                    vulnerability.severity === Severity.HIGH ? "High" : "Medium";
    
    return `${severity}: ${vulnerability.title} in ${this.getFunctionName(vulnerability)}`;
  }

  private generateSummary(vulnerability: Vulnerability, exploit: ExploitAttempt): string {
    const impact = exploit.canDrainFunds ? 
      "allows complete fund drainage" : 
      exploit.canManipulateState ? 
      "allows unauthorized state manipulation" : 
      "poses security risk";

    return `A ${vulnerability.severity.toLowerCase()} severity vulnerability has been identified that ${impact}. ` +
           `The vulnerability is located at ${vulnerability.location.file}:${vulnerability.location.line} and ` +
           `involves ${vulnerability.description.toLowerCase()}. ` +
           `Exploit simulation confirms ${exploit.status.toLowerCase()}.`;
  }

  private calculateSeverity(vulnerability: Vulnerability, exploit: ExploitAttempt): {
    cvss: string;
    solanaSpecific: string;
    financialImpact: string;
  } {
    let cvss = "0.0";
    let solanaSeverity = "Low";
    let financialImpact = "None";

    if (vulnerability.severity === Severity.CRITICAL) {
      if (exploit.canDrainFunds) {
        cvss = "9.8";
        solanaSeverity = "Complete Fund Loss";
        financialImpact = "All funds in affected accounts";
      } else if (exploit.canManipulateState) {
        cvss = "9.1";
        solanaSeverity = "State Corruption";
        financialImpact = "Potential fund loss";
      }
    } else if (vulnerability.severity === Severity.HIGH) {
      cvss = "7.5";
      solanaSeverity = "Significant Risk";
      financialImpact = "Partial fund loss possible";
    } else if (vulnerability.severity === Severity.MEDIUM) {
      cvss = "5.3";
      solanaSeverity = "Moderate Risk";
      financialImpact = "Limited impact";
    }

    return { cvss, solanaSpecific: solanaSeverity, financialImpact };
  }

  private getAffectedFiles(vulnerability: Vulnerability): string[] {
    const files: string[] = [];
    if (vulnerability.location.file) {
      files.push(vulnerability.location.file);
    }
    return files;
  }

  private getVulnerabilityClasses(vulnerability: Vulnerability): string[] {
    const classes: string[] = [];
    
    classes.push(vulnerability.category);
    
    if (vulnerability.title.includes("Type Confusion")) {
      classes.push("Type Confusion");
      classes.push("Missing Verification");
      classes.push("Privilege Escalation");
    }
    
    if (vulnerability.title.includes("Ownership")) {
      classes.push("Access Control");
      classes.push("Account Validation");
    }
    
    if (vulnerability.title.includes("Overflow")) {
      classes.push("Integer Overflow");
      classes.push("Arithmetic Error");
    }
    
    return [...new Set(classes)];
  }

  private generateTechnicalDescription(
    vulnerability: Vulnerability,
    exploit: ExploitAttempt
  ): string {
    return `${vulnerability.description}

**Location:** ${vulnerability.location.file}:${vulnerability.location.line}

**Vulnerable Code:**
\`\`\`rust
${vulnerability.codeSnippet || "Code snippet not available"}
\`\`\`

**Exploitability:** ${exploit.status}

**Evidence:**
${exploit.evidence.map(e => `- ${e}`).join("\n")}

**Attack Vector:**
${exploit.requiresConditions.map(c => `- ${c}`).join("\n")}
`;
  }

  private generateReproductionSteps(
    vulnerability: Vulnerability,
    exploit: ExploitAttempt
  ): string[] {
    const steps: string[] = [];
    
    if (exploit.testTransaction) {
      steps.push("Deploy test environment (localnet/devnet)");
      steps.push("Deploy vulnerable program");
      
      if (vulnerability.title.includes("Type Confusion")) {
        steps.push("Deploy malicious program template");
        steps.push(`Construct transaction calling ${vulnerability.location.function || "vulnerable function"}`);
        steps.push("Pass malicious program as token_program account");
        steps.push("Observe vulnerable program invoking malicious program");
        steps.push("Verify malicious program executes with vulnerable program's authority");
      } else if (vulnerability.title.includes("Ownership")) {
        steps.push("Create fake account owned by malicious program");
        steps.push(`Call ${vulnerability.location.function || "vulnerable function"} with fake account`);
        steps.push("Observe program accepting fake account");
      } else if (vulnerability.title.includes("Overflow")) {
        steps.push(`Call ${vulnerability.location.function || "vulnerable function"} with extremal values`);
        steps.push("Observe arithmetic overflow/underflow");
        steps.push("Verify bypass of validation checks");
      }
    } else {
      steps.push("Review vulnerable code at specified location");
      steps.push("Identify missing security checks");
      steps.push("Construct exploit based on vulnerability type");
    }
    
    return steps;
  }

  private generateProofOfImpact(exploit: ExploitAttempt): string[] {
    const proof: string[] = [];
    
    proof.push(...exploit.evidence);
    
    if (exploit.logs.length > 0) {
      proof.push("Simulation Logs:");
      proof.push(...exploit.logs.map(log => `  ${log}`));
    }
    
    if (exploit.canDrainFunds) {
      proof.push("Confirmed: Can drain funds from affected accounts");
    }
    
    if (exploit.canManipulateState) {
      proof.push("Confirmed: Can manipulate program state");
    }
    
    if (exploit.testTransaction) {
      proof.push("Test Transaction Available:");
      proof.push(exploit.testTransaction);
    }
    
    return proof;
  }

  private generateRemediation(vulnerability: Vulnerability): string {
    return vulnerability.recommendation || "See recommended fix in vulnerability details";
  }

  private generateTimeline(): string {
    return "Standard 90-day disclosure timeline. Will extend if fix is in progress.";
  }

  private getFunctionName(vulnerability: Vulnerability): string {
    return vulnerability.location.function || 
           vulnerability.location.file?.split("/").pop()?.replace(".rs", "") || 
           "Unknown Function";
  }
}

