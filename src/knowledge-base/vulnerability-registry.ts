/**
 * Comprehensive Vulnerability Registry
 * 
 * Based on: Comprehensive Analysis of Solana Ecosystem Vulnerabilities
 * This registry contains all known vulnerability patterns for training and detection
 */

import { VulnerabilityCategory, Severity } from "../types/vulnerability.js";

export interface VulnerabilityPattern {
  id: string;
  name: string;
  category: VulnerabilityCategory;
  severity: Severity;
  description: string;
  detectionPatterns: string[];
  codeExamples: {
    vulnerable: string;
    patched: string;
  };
  references?: string[];
}

/**
 * Solana Smart Contract (Program) Vulnerabilities
 */
export const SOLANA_PROGRAM_VULNERABILITIES: VulnerabilityPattern[] = [
  {
    id: "missing-ownership-check",
    name: "Missing Ownership Check",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.CRITICAL,
    description: "Failure to verify that an account passed into the program is owned by the expected program (e.g., the System Program or a specific Token Program).",
    detectionPatterns: [
      "AccountInfo<'info>",
      "account.owner",
      "without ownership validation",
      "missing owner check"
    ],
    codeExamples: {
      vulnerable: `pub struct Withdraw<'info> {
    /// CHECK: Missing ownership check
    pub token_account: AccountInfo<'info>,
}`,
      patched: `pub struct Withdraw<'info> {
    pub token_account: Account<'info, TokenAccount>,
}`
    },
    references: ["Helius: A Hitchhiker's Guide to Solana Program Security"]
  },
  {
    id: "missing-signer-check",
    name: "Missing Signer Check",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.CRITICAL,
    description: "Failure to verify that a required account has signed the transaction, allowing unauthorized instruction execution.",
    detectionPatterns: [
      "AccountInfo<'info> in privileged context",
      "without Signer<'info>",
      "missing is_signer check",
      "admin: AccountInfo"
    ],
    codeExamples: {
      vulnerable: `pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {
    // Missing signer check
    ctx.accounts.admin.key() == ctx.accounts.bank.admin
}`,
      patched: `pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {
    // Signer check enforced by Anchor
    // admin: Signer<'info> in context
}`
    }
  },
  {
    id: "type-confusion",
    name: "Type Confusion / Arbitrary Signed Program Invocation",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Using an account for a purpose other than its intended type, or allowing a program to be invoked with arbitrary data.",
    detectionPatterns: [
      "invoke_signed with arbitrary program",
      "Program<'info> without validation",
      "type confusion",
      "arbitrary CPI"
    ],
    codeExamples: {
      vulnerable: `pub fn process(ctx: Context<Process>, program_id: Pubkey) -> Result<()> {
    // No validation of program_id
    invoke(&instruction, &ctx.accounts)?;
}`,
      patched: `pub fn process(ctx: Context<Process>) -> Result<()> {
    require!(
        ctx.accounts.token_program.key() == spl_token::ID,
        ErrorCode::InvalidProgram
    );
}`
    }
  },
  {
    id: "integer-overflow",
    name: "Integer Overflow/Underflow",
    category: VulnerabilityCategory.ARITHMETIC,
    severity: Severity.HIGH,
    description: "Arithmetic operations exceeding the maximum or minimum value of the data type, leading to unexpected results.",
    detectionPatterns: [
      "unchecked arithmetic",
      "+ without checked_add",
      "- without checked_sub",
      "* without checked_mul",
      "u64::MAX",
      "overflow"
    ],
    codeExamples: {
      vulnerable: `let new_balance = old_balance + amount; // Potential overflow`,
      patched: `let new_balance = old_balance.checked_add(amount)
    .ok_or(ErrorCode::Overflow)?;`
    }
  },
  {
    id: "precision-loss",
    name: "Precision Loss",
    category: VulnerabilityCategory.ARITHMETIC,
    severity: Severity.MEDIUM,
    description: "Errors in fixed-point arithmetic, often when converting between integer and floating-point representations.",
    detectionPatterns: [
      "division before multiplication",
      "f64 or f32 usage",
      "rounding errors",
      "precision loss"
    ],
    codeExamples: {
      vulnerable: `let result = (amount * rate) / 100; // Precision loss`,
      patched: `let result = (amount * rate)
    .checked_div(100)
    .ok_or(ErrorCode::DivisionByZero)?;`
    }
  },
  {
    id: "reinitialization",
    name: "Re-initialization Attack",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Allowing an account that has already been initialized to be initialized again, resetting its state.",
    detectionPatterns: [
      "initialize without init constraint",
      "missing initialized flag check",
      "reinitialization",
      "state reset"
    ],
    codeExamples: {
      vulnerable: `#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)] // Missing 'init'
    pub config: Account<'info, Config>,
}`,
      patched: `#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 32)]
    pub config: Account<'info, Config>,
}`
    }
  },
  {
    id: "crank-abuse",
    name: "Crank/Permissionless Instruction Abuse",
    category: VulnerabilityCategory.LOGIC_ERROR,
    severity: Severity.MEDIUM,
    description: "Exploiting instructions intended to be permissionless to gain an unfair advantage or cause denial of service.",
    detectionPatterns: [
      "permissionless instruction",
      "crank without rate limiting",
      "front-running",
      "DoS via spam"
    ],
    codeExamples: {
      vulnerable: `pub fn liquidate(ctx: Context<Liquidate>) -> Result<()> {
    // No rate limiting or access control
    // Can be spammed
}`,
      patched: `pub fn liquidate(ctx: Context<Liquidate>) -> Result<()> {
    // Add cooldown or access control
    require!(
        clock.unix_timestamp - last_liquidation > COOLDOWN,
        ErrorCode::TooFrequent
    );
}`
    }
  },
  {
    id: "account-data-mismatch",
    name: "Incorrect Account Data Matching",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.HIGH,
    description: "Failure to verify that the data within an account matches the expected structure or content before processing.",
    detectionPatterns: [
      "account data without validation",
      "missing discriminator check",
      "data structure mismatch"
    ],
    codeExamples: {
      vulnerable: `let account_data = ctx.accounts.account.data.borrow(); // No validation`,
      patched: `let account = Account::<MyAccount>::try_deserialize(
    &mut &ctx.accounts.account.data.borrow()[..]
)?;`
    }
  },
  {
    id: "pda-abuse",
    name: "PDA (Program Derived Address) Abuse",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Exploiting logic that relies on PDAs, such as allowing an attacker to generate a valid PDA that was not intended.",
    detectionPatterns: [
      "PDA without canonical bump",
      "weak seed validation",
      "PDA generation without constraints"
    ],
    codeExamples: {
      vulnerable: `let (pda, bump) = Pubkey::find_program_address(&[seed], program_id);`,
      patched: `let (pda, bump) = Pubkey::find_program_address(&[seed], program_id);
require!(bump == expected_bump, ErrorCode::InvalidBump);`
    }
  },
  {
    id: "sysvar-spoofing",
    name: "Sysvar Account Spoofing",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Program accepts sysvar accounts (Clock, Rent, etc.) from user input instead of using Clock::get() or Rent::get(). Attackers can provide fake sysvar accounts with manipulated data.",
    detectionPatterns: [
      "Clock::from_account_info",
      "Rent::from_account_info",
      "next_account_info with sysvar",
      "sysvar account from user input"
    ],
    codeExamples: {
      vulnerable: `let clock_account = next_account_info(account_info_iter)?;
let clock = Clock::from_account_info(clock_account)?; // VULNERABLE!`,
      patched: `let clock = Clock::get()?; // Safe - gets real sysvar`
    },
    references: ["Wormhole $320M Hack - Sysvar Spoofing"]
  },
  {
    id: "account-close-attack",
    name: "Account Close/Rent Reclamation Attack",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.CRITICAL,
    description: "Account is closed and lamports transferred without verifying ownership. Attackers can close accounts they don't own and drain rent.",
    detectionPatterns: [
      "lamports.borrow_mut() = 0",
      "close account without ownership check",
      "rent reclamation",
      "account close without constraint"
    ],
    codeExamples: {
      vulnerable: `**destination.lamports.borrow_mut() += source.lamports();
**source.lamports.borrow_mut() = 0; // No ownership check!`,
      patched: `require!(source.owner == program_id, ErrorCode::InvalidOwner);
**destination.lamports.borrow_mut() += source.lamports();
**source.lamports.borrow_mut() = 0;`
    }
  },
  {
    id: "duplicate-mutable-accounts",
    name: "Duplicate Mutable Accounts",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Same account appears multiple times in a context without validation. Can lead to double rewards, state corruption, or other exploits.",
    detectionPatterns: [
      "multiple mutable accounts",
      "same account twice",
      "duplicate account check missing",
      "constraint = account_a.key() != account_b.key()"
    ],
    codeExamples: {
      vulnerable: `#[account(mut)]
pub account_a: AccountInfo<'info>,
#[account(mut)]
pub account_b: AccountInfo<'info>, // No duplicate check!`,
      patched: `#[account(mut)]
pub account_a: AccountInfo<'info>,
#[account(mut)]
#[constraint(account_a.key() != account_b.key())]
pub account_b: AccountInfo<'info>,`
    }
  },
  {
    id: "token-2022-hooks",
    name: "Missing Token-2022 Transfer Hook Support",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.HIGH,
    description: "Token-2022 transfer without checking for and executing transfer hooks. Can bypass important security checks.",
    detectionPatterns: [
      "token_2022::instruction::transfer",
      "missing transfer hook",
      "no additional_required_accounts"
    ],
    codeExamples: {
      vulnerable: `token_2022::instruction::transfer(...); // Missing hook check`,
      patched: `// Check for transfer hooks and include additional accounts
if let Some(hook_program) = get_transfer_hook_program(&mint)? {
    execute_transfer_hook(...)?;
}`
    }
  },
  {
    id: "token-2022-confidential",
    name: "Ignoring Confidential Transfer Balance",
    category: VulnerabilityCategory.ARITHMETIC,
    severity: Severity.MEDIUM,
    description: "Reading token amount without considering confidential balance in Token-2022 accounts.",
    detectionPatterns: [
      "token_account.amount",
      "confidential transfer",
      "available_balance"
    ],
    codeExamples: {
      vulnerable: `let balance = token_account.amount; // Ignores confidential balance`,
      patched: `let balance = get_available_balance(&token_account)?; // Includes confidential`
    }
  },
  {
    id: "token-2022-extensions",
    name: "Not Checking Token-2022 Extensions",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.MEDIUM,
    description: "Processing mint without checking for Token-2022 extensions that may affect behavior.",
    detectionPatterns: [
      "get_mint_info without extension check",
      "missing ExtensionType check"
    ],
    codeExamples: {
      vulnerable: `let mint_info = get_mint_info(&mint_account)?; // No extension check`,
      patched: `let mint_info = get_mint_info(&mint_account)?;
let extensions = get_extension_types(&mint_account)?;
// Handle extensions appropriately`
    }
  }
];

/**
 * Website and Front-End (dApp) Vulnerabilities
 */
export const DAPP_VULNERABILITIES: VulnerabilityPattern[] = [
  {
    id: "supply-chain-attack",
    name: "Supply Chain Attacks",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Compromise of a third-party library used by the dApp, injecting malicious code.",
    detectionPatterns: [
      "outdated npm packages",
      "suspicious package versions",
      "unverified dependencies",
      "package-lock.json mismatches"
    ],
    codeExamples: {
      vulnerable: `import { Wallet } from '@suspicious-package/wallet';`,
      patched: `// Use verified, audited packages
import { Wallet } from '@solana/web3.js';`
    },
    references: ["Supply Chain Attacks in The Solana Ecosystem - Adevar Labs"]
  },
  {
    id: "dns-hijacking",
    name: "DNS Hijacking / Cache Poisoning",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Attacker redirects the user to a malicious version of the dApp website.",
    detectionPatterns: [
      "missing HTTPS",
      "no certificate pinning",
      "DNS not verified"
    ],
    codeExamples: {
      vulnerable: `// No domain verification`,
      patched: `// Verify domain and use certificate pinning`
    }
  },
  {
    id: "xss",
    name: "Cross-Site Scripting (XSS)",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.HIGH,
    description: "Injecting malicious scripts into the dApp's website through user input.",
    detectionPatterns: [
      "innerHTML without sanitization",
      "eval(",
      "dangerouslySetInnerHTML",
      "user input in script tags"
    ],
    codeExamples: {
      vulnerable: `element.innerHTML = userInput; // XSS risk`,
      patched: `element.textContent = sanitize(userInput);`
    }
  },
  {
    id: "phishing",
    name: "Phishing / Social Engineering",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Creating fake websites or using deceptive communication to trick users.",
    detectionPatterns: [
      "typosquatting domains",
      "fake wallet connection prompts",
      "seed phrase requests"
    ],
    codeExamples: {
      vulnerable: `// Asking for seed phrase in UI`,
      patched: `// Never request seed phrases`
    }
  },
  {
    id: "address-poisoning",
    name: "Address Poisoning Attack",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Frontend vulnerability where users can be tricked into sending funds to attacker-controlled addresses that look similar to legitimate addresses.",
    detectionPatterns: [
      "no address validation",
      "address truncation",
      "copying from transaction history",
      "similar address display"
    ],
    codeExamples: {
      vulnerable: `await connection.sendTransaction(transaction, [wallet], {
  skipPreflight: false
}); // No address validation`,
      patched: `// Validate and show full address
if (!PublicKey.isOnCurve(recipient)) {
  throw new Error("Invalid address");
}
// Show full address in UI, use address book`
    },
    references: ["Address Poisoning Attacks in Solana"]
  },
  {
    id: "pda-seed-collision",
    name: "PDA Seed Collision",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.HIGH,
    description: "All PDA seeds are user-controlled, allowing attackers to generate colliding PDAs and bypass access controls.",
    detectionPatterns: [
      "find_program_address with user seeds",
      "all seeds user-controlled",
      "short PDA seeds",
      "no program-controlled seed"
    ],
    codeExamples: {
      vulnerable: `let (pda, _) = Pubkey::find_program_address(
    &[user_seed1, user_seed2], // All user-controlled!
    program_id
);`,
      patched: `let (pda, bump) = Pubkey::find_program_address(
    &[b"vault", user_seed, program_id.as_ref()], // Include program-controlled seed
    program_id
);`
    }
  },
  {
    id: "oracle-manipulation",
    name: "Oracle Manipulation",
    category: VulnerabilityCategory.ORACLE_MANIPULATION,
    severity: Severity.HIGH,
    description: "Using oracle prices without validation makes protocols vulnerable to price manipulation attacks via flash loans.",
    detectionPatterns: [
      "price used without validation",
      "no confidence check",
      "no staleness check",
      "single oracle source",
      "no TWAP"
    ],
    codeExamples: {
      vulnerable: `let price = oracle_account.price; // No validation!`,
      patched: `require!(oracle_account.status == PriceStatus::Trading, ErrorCode::InvalidPrice);
require!(oracle_account.confidence < MAX_CONFIDENCE, ErrorCode::LowConfidence);
require!(Clock::get()?.unix_timestamp - oracle_account.timestamp < MAX_STALENESS, ErrorCode::StalePrice);
let price = oracle_account.price;`
    },
    references: ["Mango Markets Exploit - Oracle Manipulation"]
  },
  {
    id: "initialization-attack",
    name: "Initialization Attack",
    category: VulnerabilityCategory.SOLANA_ACCOUNT_LIFECYCLE,
    severity: Severity.CRITICAL,
    description: "Initialize function can be called multiple times, allowing attackers to reset state or reinitialize accounts.",
    detectionPatterns: [
      "initialize without check",
      "no is_initialized flag",
      "discriminator overwrite",
      "missing init constraint"
    ],
    codeExamples: {
      vulnerable: `pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    // No check if already initialized!
    ctx.accounts.state.data = ...;
    Ok(())
}`,
      patched: `pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    require!(!ctx.accounts.state.is_initialized, ErrorCode::AlreadyInitialized);
    ctx.accounts.state.is_initialized = true;
    ctx.accounts.state.data = ...;
    Ok(())
}`
    }
  },
  {
    id: "mev-frontrunning",
    name: "MEV/Front-running",
    category: VulnerabilityCategory.ORACLE_MANIPULATION,
    severity: Severity.HIGH,
    description: "Swap functions without slippage protection are vulnerable to sandwich attacks and front-running by MEV bots.",
    detectionPatterns: [
      "swap without slippage",
      "no min_amount_out",
      "auction without commit-reveal",
      "first-come-first-serve"
    ],
    codeExamples: {
      vulnerable: `pub fn swap(ctx: Context<Swap>, amount_in: u64) -> Result<()> {
    // No slippage protection!
    let amount_out = calculate_output(amount_in);
    transfer(amount_out)?;
    Ok(())
}`,
      patched: `pub fn swap(ctx: Context<Swap>, amount_in: u64, min_amount_out: u64) -> Result<()> {
    let amount_out = calculate_output(amount_in);
    require!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);
    transfer(amount_out)?;
    Ok(())
}`
    }
  },
  {
    id: "upgrade-authority-attack",
    name: "Upgrade Authority Attack",
    category: VulnerabilityCategory.GOVERNANCE,
    severity: Severity.HIGH,
    description: "Program upgrade authority controlled by single key without multisig or timelock allows immediate malicious upgrades.",
    detectionPatterns: [
      "single upgrade authority",
      "no multisig",
      "admin without timelock",
      "proxy pattern"
    ],
    codeExamples: {
      vulnerable: `// Anchor.toml
[programs.localnet]
upgrade_authority = "single_key" // Vulnerable!`,
      patched: `// Use multisig or make immutable
[programs.localnet]
upgrade_authority = "multisig_address" // Or remove for immutable`
    }
  },
  {
    id: "wallet-integration-flaws",
    name: "Wallet Integration Flaws",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.HIGH,
    description: "Errors in how the dApp interacts with the user's wallet, potentially requesting excessive permissions.",
    detectionPatterns: [
      "setApprovalForAll without warning",
      "excessive permissions",
      "transaction without user confirmation"
    ],
    codeExamples: {
      vulnerable: `await wallet.sendTransaction(tx); // No confirmation`,
      patched: `// Show transaction details and get explicit user confirmation`
    }
  }
];

/**
 * Core Ecosystem and Protocol Vulnerabilities
 */
export const ECOSYSTEM_VULNERABILITIES: VulnerabilityPattern[] = [
  {
    id: "bridge-exploits",
    name: "Bridge Exploits",
    category: VulnerabilityCategory.LOGIC_ERROR,
    severity: Severity.CRITICAL,
    description: "Vulnerabilities in cross-chain bridges that allow attackers to mint unauthorized tokens or drain funds.",
    detectionPatterns: [
      "signature verification flaws",
      "bridge contract logic errors",
      "unauthorized minting"
    ],
    codeExamples: {
      vulnerable: `// Weak signature verification in bridge`,
      patched: `// Multi-sig and robust signature verification`
    }
  },
  {
    id: "admin-key-compromise",
    name: "Admin Key/Governance Compromise",
    category: VulnerabilityCategory.ACCESS_CONTROL,
    severity: Severity.CRITICAL,
    description: "Theft or misuse of a project's multisig or admin keys, allowing malicious upgrades or fund drainage.",
    detectionPatterns: [
      "single admin key",
      "weak multisig",
      "admin key in code",
      "hardcoded keys"
    ],
    codeExamples: {
      vulnerable: `const ADMIN_KEY = "hardcoded_key_here";`,
      patched: `// Use multisig with time-lock and proper key management`
    }
  }
];

/**
 * EVM/Solidity Vulnerabilities (for cross-chain analysis)
 */
export const EVM_VULNERABILITIES: VulnerabilityPattern[] = [
  {
    id: "reentrancy",
    name: "Reentrancy Vulnerability",
    category: VulnerabilityCategory.REENTRANCY,
    severity: Severity.CRITICAL,
    description: "Function makes external call before updating state, violating Checks-Effects-Interactions pattern.",
    detectionPatterns: [
      "external call before state update",
      ".call() before balance update",
      "missing nonReentrant"
    ],
    codeExamples: {
      vulnerable: `function withdraw() {
    msg.sender.call{value: balance}("");
    balance = 0; // Too late
}`,
      patched: `function withdraw() nonReentrant {
    balance = 0; // Update first
    msg.sender.call{value: balance}("");
}`
    }
  },
  {
    id: "weak-oracle",
    name: "Weak Oracle Implementation",
    category: VulnerabilityCategory.ORACLE_MANIPULATION,
    severity: Severity.HIGH,
    description: "Using single-source or manipulable price feeds that can be exploited with flash loans.",
    detectionPatterns: [
      "getReserves() without TWAP",
      "single DEX price source",
      "no Chainlink oracle",
      "spot price only"
    ],
    codeExamples: {
      vulnerable: `uint price = reserve1 / reserve0; // Manipulable`,
      patched: `uint price = getTWAP(30 minutes); // Time-weighted`
    }
  }
];

/**
 * Complete vulnerability registry
 */
export const VULNERABILITY_REGISTRY: VulnerabilityPattern[] = [
  ...SOLANA_PROGRAM_VULNERABILITIES,
  ...DAPP_VULNERABILITIES,
  ...ECOSYSTEM_VULNERABILITIES,
  ...EVM_VULNERABILITIES
];

/**
 * Get vulnerability pattern by ID
 */
export function getVulnerabilityPattern(id: string): VulnerabilityPattern | undefined {
  return VULNERABILITY_REGISTRY.find(v => v.id === id);
}

/**
 * Get vulnerabilities by category
 */
export function getVulnerabilitiesByCategory(category: VulnerabilityCategory): VulnerabilityPattern[] {
  return VULNERABILITY_REGISTRY.filter(v => v.category === category);
}

/**
 * Get all detection patterns as a searchable list
 */
export function getAllDetectionPatterns(): string[] {
  return VULNERABILITY_REGISTRY.flatMap(v => v.detectionPatterns);
}

